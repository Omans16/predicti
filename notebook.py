# -*- coding: utf-8 -*-
"""notebook.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-QoeH1rIqTH6QlkVFenJXzSo3-KBs-aY

## 1. Import Library

Pada tahap ini, Anda perlu mengimpor beberapa pustaka (library) Python yang dibutuhkan untuk analisis data dan pembangunan model machine learning.
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.calibration import LabelEncoder
from sklearn.discriminant_analysis import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.tree import DecisionTreeClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.ensemble import RandomForestClassifier
from xgboost import XGBClassifier
from lightgbm import LGBMClassifier
from sklearn.metrics import confusion_matrix, accuracy_score, precision_score, recall_score, f1_score, roc_auc_score
from sklearn.metrics import classification_report

"""## 2. Data Understanding

### Load Dataset
"""

cardio_disease = pd.read_csv("cardiovascular.csv")
cardio_disease

cardio_disease.info()

"""Berdasarkan informasi dataset tersebut dapat diketahui bahwa:
- jumlah data : 70000
- jumlah label : 13 kolom
- Label target : cardio (1 = memiliki penyakit cardiovascular, 0 = tidak)

"""

cardio_disease.describe()

cardio_disease['age'] = (cardio_disease['age'] / 365).astype(int)

# Tambahin BMI
cardio_disease['BMI'] = cardio_disease['weight'] / ((cardio_disease['height'] / 100) ** 2)

cardio_disease

# Ambil hanya kolom numerikal
numeric_cols = cardio_disease.select_dtypes(include='number').columns
# Hitung Q1, Q3, dan IQR hanya untuk kolom numerikal
Q1 = cardio_disease[numeric_cols].quantile(0.25)
Q3 = cardio_disease[numeric_cols].quantile(0.75)
IQR = Q3 - Q1
# Buat filter untuk menghapus baris yang mengandung outlier di kolom numerikal
filter_outliers = ~((cardio_disease[numeric_cols] < (Q1 - 1.5 * IQR)) |
                    (cardio_disease[numeric_cols] > (Q3 + 1.5 * IQR))).any(axis=1)
# Terapkan filter ke dataset asli (termasuk kolom non-numerikal)
cardio_disease = cardio_disease[filter_outliers]
# Cek ukuran dataset setelah outlier dihapus
cardio_disease.shape

"""## 3. Exploratory Data Analysis

### Cek Distribusi Target
"""

sns.set_theme(style="whitegrid")
plt.rcParams['figure.figsize'] = (10, 6)

sns.countplot(x='cardio', data=cardio_disease, palette='Set1')
plt.title('Distribusi Target: cardio')
plt.xlabel('Heart Disease (0 = No, 1 = Yes)')
plt.ylabel('Jumlah')
plt.show()

"""Berdasarkan hasil visualisasi distribusi target cardiovascular:

- 0 tidak memiliki penyakit jantung ~ 35000 sampel.
- 1 terdapat penyakit jantung ~ 35000 sampel.
- Keseimbangan pada kelas ini sangat baik karena tidak memerlukan penyeimbang data seperti oversampling atau undersampling
"""

sns.histplot(data=cardio_disease, x='age', hue='cardio', multiple='stack', bins=30, palette='Set1')
plt.title('Distribusi Usia berdasarkan Cardiovascular')
plt.xlabel('Age')
plt.ylabel('Jumlah')
plt.show()

"""Berdasarkan hasil visualisasi :

- Kasus penyakit jantung sering terjadi umur ~40 tahun sapai ~65 tahun
- Kasus penyakit jantung paling banyak terjadi pada usia 50 - 65 tahun
"""

sns.countplot(x='gender', hue='cardio', data=cardio_disease, palette='Set1')
plt.title('Distribusi kelamin terhadap cardiovascular')
plt.xlabel('kelamin')
plt.ylabel('Jumlah')
plt.show()

"""Berdasarkan hasil visualisasi:

1 = perempuan, 2 = laki-laki

- perempuan mendominasi penyakik cardiovascular
- laki-laki terlihat cukup banyak tetapi tidak sebanyak perempuan

### Korelasi antar fitur numerik
"""

numeric_features = cardio_disease.select_dtypes(include=['int64', 'float64']).columns
sns.heatmap(cardio_disease[numeric_features].corr(), annot=True, cmap='coolwarm', fmt='.2f')
plt.title('Heatmap Korelasi antar Fitur Numerik')
plt.show()

"""Berdasarkan heatmap korelasi antar fitur numerik, dapat disimpulkan bahwa beberapa fitur menunjukkan hubungan yang cukup signifikan satu sama lain.

Terlihat bahwa BMI memiliki korelasi tinggi terhadap weight (0.84), yang wajar karena BMI merupakan fungsi dari berat dan tinggi badan. Korelasi positif juga terlihat antara ap_hi (tekanan darah sistolik) dan cardio (0.45), serta cholesterol dan cardio (0.22), yang mengindikasikan bahwa tekanan darah dan kadar kolesterol cenderung meningkat pada pasien dengan penyakit cardiovascular. Sementara itu, fitur seperti smoke, alco, dan active menunjukkan korelasi rendah terhadap variabel target cardio, yang bisa jadi tidak terlalu berpengaruh dalam model prediksi. Korelasi yang rendah antar sebagian besar fitur juga menunjukkan rendahnya multikolinearitas, yang baik untuk kestabilan model pembelajaran mesin.

## 4. Data Preparation

### Mengecek Missing Value
"""

total_rows = cardio_disease.shape[0]
missing_data = cardio_disease.isnull().sum()
percent_missing = (missing_data / total_rows) * 100

# Membuat DataFrame baru untuk hasil
missing_values_df = pd.DataFrame({
    'Jumlah Data Hilang': missing_data,
    'Persentase Data Hilang': percent_missing.map('{:.2f}%'.format)
})

# Menampilkan tabel
print(missing_values_df)

"""Berdasarkan hasil pengecekan, tidak ditemukan nilai yang hilang (missing values) dalam dataset. Oleh karena itu, tidak diperlukan langkah tambahan untuk imputasi atau penghapusan data. Dataset siap digunakan untuk tahap analisis atau pemodelan lebih lanjut."""

print("Jumlah baris sebelum:", cardio_disease.shape[0])
print("Jumlah duplikat:", cardio_disease.duplicated().sum())
cardio_disease = cardio_disease.drop_duplicates()
print("Jumlah baris setelah menghapus duplikat:", cardio_disease.shape[0])

"""Pemeriksaan data menunjukkan bahwa tidak terdapat baris duplikat dalam dataset. Ini menunjukkan bahwa data sudah bersih dan siap digunakan untuk tahap analisis atau pemodelan tanpa perlu pembersihan lebih lanjut terkait duplikasi."""

cardio_disease.drop(['id', 'active', 'smoke', 'alco'], axis=1, inplace=True)

cardio_disease.head()

scaler = StandardScaler()
num_cols = ['age', 'weight', 'ap_hi' , 'ap_lo']
cardio_disease[num_cols] = scaler.fit_transform(cardio_disease[num_cols])

cardio_disease.sample(10)

"""Tujuan scaling ini adalah untuk memastikan semua fitur memiliki skala yang seragam sehingga model machine learning dapat belajar secara optimal dan tidak bias terhadap fitur tertentu yang memiliki rentang nilai besar.

### Split Data
"""

X = cardio_disease.drop(columns=['cardio'])
y = cardio_disease['cardio'].astype(int)  # pastikan integer


# Split dataset menjadi training dan testing set (80% train, 20% test)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Menampilkan ukuran dataset setelah splitting
print("Ukuran data latih:", X_train.shape, y_train.shape)
print("Ukuran data uji:", X_test.shape, y_test.shape)

print("Distribusi kelas:", np.bincount(y_train))

"""## 5. Modelling

### XGBClassifier
"""

xgb = XGBClassifier(use_label_encoder=False, eval_metric='logloss', random_state=42)

# Melatih model
xgb.fit(X_train, y_train)

# Prediksi
y_pred_xgb = xgb.predict(X_test)
y_proba_xgb = xgb.predict_proba(X_test)[:, 1]

# Evaluasi
accuracy_xgb = accuracy_score(y_test, y_pred_xgb)
report_xgb = classification_report(y_test, y_pred_xgb)
precision_xgb = precision_score(y_test, y_pred_xgb, average='weighted')
recall_xgb = recall_score(y_test, y_pred_xgb, average='weighted')
f1_xgb = f1_score(y_test, y_pred_xgb, average='weighted')
roc_xgb = roc_auc_score(y_test, y_proba_xgb)

"""### LightGBM Classifier"""

lgb = LGBMClassifier(random_state=42)

# Melatih model
lgb.fit(X_train, y_train)

# Prediksi
y_pred_lgb = lgb.predict(X_test)
y_proba_lgb = lgb.predict_proba(X_test)[:, 1]

# Evaluasi
accuracy_lgb = accuracy_score(y_test, y_pred_lgb)
report_lgb = classification_report(y_test, y_pred_lgb)
precision_lgb = precision_score(y_test, y_pred_lgb, average='weighted')
recall_lgb = recall_score(y_test, y_pred_lgb, average='weighted')
f1_lgb = f1_score(y_test, y_pred_lgb, average='weighted')
roc_lgb = roc_auc_score(y_test, y_proba_lgb)

"""### Logistic Regression"""

logreg = LogisticRegression(max_iter=1000, random_state=42)
logreg.fit(X_train, y_train)

y_pred_logreg = logreg.predict(X_test)
y_proba_logreg = logreg.predict_proba(X_test)[:, 1]

# Mengevaluasi performa model
accuracy_logreg = accuracy_score(y_test, y_pred_logreg)
report_logreg = classification_report(y_test, y_pred_logreg)
precision_logreg = precision_score(y_test, y_pred_logreg, average='weighted')
recall_logreg = recall_score(y_test, y_pred_logreg, average='weighted')
f1_logreg = f1_score(y_test, y_pred_logreg, average='weighted')
roc_logreg = roc_auc_score(y_test, y_proba_logreg)

"""### Random Forest"""

rf = RandomForestClassifier(random_state=42)
rf.fit(X_train, y_train)

y_pred_rf = rf.predict(X_test)
y_proba_rf = rf.predict_proba(X_test)[:, 1]

accuracy_rf = accuracy_score(y_test, y_pred_rf)
report_rf = classification_report(y_test, y_pred_rf)
precision_rf = precision_score(y_test, y_pred_rf, average='weighted')
recall_rf = recall_score(y_test, y_pred_rf, average='weighted')
f1_rf = f1_score(y_test, y_pred_rf, average='weighted')
roc_rf = roc_auc_score(y_test, y_proba_rf)

"""## 6. Evaluasi Model

### XGBClassifier
"""

metrics_xgb = pd.DataFrame({
    "Matriks": ["Accuracy", "Precision", "Recall", "F1-Score", "ROC AUC Score"],
    "Score": [accuracy_xgb, precision_xgb, recall_xgb, f1_xgb, roc_xgb]
})

metrics_xgb

cm_xgb = confusion_matrix(y_test, y_pred_xgb)

plt.figure(figsize=(8, 6))
sns.heatmap(cm_xgb, annot=True, fmt="d", cmap="Greens", xticklabels=set(y_test), yticklabels=set(y_test))
plt.xlabel("Predicted Label")
plt.ylabel("True Label")
plt.title("Confusion Matrix - XGBoost")
plt.show()

"""Model XGBoost Classifier menunjukkan performa yang sangat baik dalam mendeteksi penyakit cardiovascular berdasarkan data yang diberikan. Dengan akurasi sebesar 73,18%, model ini mampu mengklasifikasikan data dengan cukup tepat. Nilai precision (73,38%) dan recall (73,18%) yang seimbang menunjukkan bahwa model tidak bias terhadap salah satu kelas dan mampu mengenali kasus positif maupun negatif secara konsisten. Nilai F1-score sebesar 72,93% mengindikasikan keseimbangan yang baik antara presisi dan sensitivitas. Sementara itu, ROC AUC Score sebesar 78,72% mencerminkan kemampuan model yang tinggi dalam membedakan antara dua kelas.

### LightGBM Classifier
"""

metrics_lgb = pd.DataFrame({
    "Matriks": ["Accuracy", "Precision", "Recall", "F1-Score", "ROC AUC Score"],
    "Score": [accuracy_lgb, precision_lgb, recall_lgb, f1_lgb, roc_lgb]
})

metrics_lgb

cm_lgb = confusion_matrix(y_test, y_pred_lgb)

plt.figure(figsize=(8, 6))
sns.heatmap(cm_lgb, annot=True, fmt="d", cmap="Blues", xticklabels=set(y_test), yticklabels=set(y_test))
plt.xlabel("Predicted Label")
plt.ylabel("True Label")
plt.title("Confusion Matrix - LightGBM")
plt.show()

"""Model LightGBM Classifier menunjukkan performa yang baik dalam klasifikasi penyakit cardiovascular. Dengan akurasi sebesar 73,70%, model ini sedikit lebih unggul dibandingkan XGBoost. Nilai precision (73,93%) dan recall (73,70%) yang tinggi menunjukkan bahwa model ini mampu memprediksi kedua kelas dengan baik dan seimbang. F1-score sebesar 73,44% juga memperkuat bukti bahwa model ini efektif dalam menjaga keseimbangan antara false positives dan false negatives. ROC AUC Score sebesar 79,47% menandakan kemampuan model dalam membedakan antara pasien yang memiliki dan tidak memiliki penyakit cardiovascular secara sangat baik.

### Logistic Regression
"""

# Menampilkan dalam DataFrame
metrics_logreg = pd.DataFrame({
    "Matriks": ["Accuracy", "Precision", "Recall", "F1-Score", "ROC AUC Score"],
    "Score": [accuracy_logreg, precision_logreg, recall_logreg, f1_logreg, roc_logreg]
})

metrics_logreg

cm_logreg = confusion_matrix(y_test, y_pred_logreg)

# Visualisasi Confusion Matrix
plt.figure(figsize=(8, 6))
sns.heatmap(cm_logreg, annot=True, fmt="d", cmap="Oranges", xticklabels=set(y_test), yticklabels=set(y_test))
plt.xlabel("Predicted Label")
plt.ylabel("True Label")
plt.title("Confusion Matrix - K-Nearest Neighbours")
plt.show()

"""Model Logistic Regression menunjukkan performa yang kompetitif dalam memprediksi penyakit cardiovascular. Dengan akurasi sebesar 73,21%, model ini memberikan hasil klasifikasi yang cukup baik. Nilai precision (73,59%) dan recall (73,21%) yang seimbang mengindikasikan bahwa model ini konsisten dalam mengenali kedua kelas. F1-score sebesar 72,86% menunjukkan bahwa model menjaga keseimbangan prediksi. Meskipun model ini lebih sederhana dibandingkan XGBoost atau LightGBM, ROC AUC Score sebesar 79,11% menunjukkan bahwa Logistic Regression tetap memiliki kemampuan dalam membedakan antara pasien yang memiliki dan tidak memiliki penyakit.

### Random Forest
"""

# Menampilkan dalam DataFrame
metrics_rf = pd.DataFrame({
    "Matriks": ["Accuracy", "Precision", "Recall", "F1-Score", "ROC AUC"],
    "Score": [accuracy_rf, precision_rf, recall_rf, f1_rf, roc_rf]
})

metrics_rf

cm_rf = confusion_matrix(y_test, y_pred_rf)

# Visualisasi Confusion Matrix
plt.figure(figsize=(8, 6))
sns.heatmap(cm_rf, annot=True, fmt="d", cmap="Oranges", xticklabels=set(y_test), yticklabels=set(y_test))
plt.xlabel("Predicted Label")
plt.ylabel("True Label")
plt.title("Confusion Matrix - K-Nearest Neighbours")
plt.show()

"""Model Random Forest Classifier memberikan hasil klasifikasi yang cukup solid dalam mendeteksi penyakit cardiovascular. Dengan akurasi sebesar 70,07%, model ini menunjukkan performa yang stabil namun sedikit lebih rendah dibandingkan Logistic Regression, XGBoost, maupun LightGBM. Nilai precision (70,02%), recall (70,07%), dan F1-score (70,02%) yang hampir identik menunjukkan konsistensi model dalam mengklasifikasikan data, meskipun tanpa keunggulan signifikan. Sementara itu, ROC AUC Score sebesar 75,77% menunjukkan bahwa model masih memiliki kemampuan yang baik dalam membedakan antara pasien yang memiliki dan tidak memiliki penyakit."""